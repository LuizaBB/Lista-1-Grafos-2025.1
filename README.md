# Lista 1 Grafos 2025.1
 Lista de Algoritmos para Caminho Mínimo
>Os algoritmos implementados foram baseados nos pseudocódigos contidos no livro **Grafos: Introdução e Prática** (Boaventura Netto, Paulo Oswaldo)
## Instruções de compilação:

## Questão 1: Estação central para metrô
Considerando que a questão oferta um grafo **não direcionado** represetando as estações de um metrô e precisa, como primeiro passo, definir a estação central para o mesmo, foi escolhido o algoritmo de caminho mínimo FLoyd, por trabalhar com o cálculo de distâncias mínimas com relação à todos os vértices (não somente em relação à um vértice de referência, como Bellmann-Ford e Dijkstra), o que fornece uma base de informações mais ampla para encontrar o vértice central (definido como aquele que tem menor custo possível para os outros vértices).
### Em relação à implementação:
Considerando que o algoritmo Floyd se baseia apenas em matrizes, o ínicio da implementação envolveu aplicar a representação de matrizes adjacentes para o grafo de entrada com a linha 54 para criação do objeto Grafo e linhas 55 a 56 para preenchimento do grafo de acordo com a entrada dada.  
Além disso, a função contendo o algoritmo recebe dois parâmetros: O grafo em si e o "primeiro vértice" do mesmo denominada "IR" (considerando que os vértices seguem uma ordem crescente), visando ajustar o tamanho das matrizes e dos intervalos ao longo da implementação (principalmente para processar tanto matrizes com vértices [0, 1, 2, ...] quanto [1, 2, 3, ...]).  

O pseudocódigo inicia com a declaração de duas matrizes tamanho N X N: D (recebe a matriz que representa o grafo) e R (das coordenadas (i,j) que representam uma aresta, recebe o segundo vértice j). A delimitaçaõ da quantidade de linhas N para ambas matrizes ocorre nas linhas 17 e 18, as quais declaram D e R com ma quantidade N+1 de listas vazias, respectivamente (N+1 para o caso do grafo utilizar um intervalo de vértices [1, N+1], e vazia porque será preenchida com outras listas para as colunas). Na aplicação do algoritmo ambas foram preenchidas simultaneamente (possível por ambas terem o mesmo tamanho) com um *for loop* com *range* (0, N+1) que preenche a matriz D com 1000 (o inteiro máximo escolhido para representar arestas inexistentes) e R com 0 (inteiro usado para indicar impossibilidade de backtracking, pela falta de aresta), que correspondem às linhas 19 à 21.<br/>

Nas linhas 22 à 28 tem o tratamento inicial dessas matrizes antes do algoritmo em si: Com dois *for loops* com intervalo (IR, N+IR) verifica se a coordenada (i,j) no grafo é diferente de 0 (se sim, há aresta para ser colocada na matriz D e vértice j na matriz R) e se i=j (em caso afirmativo, se trata de um laço (entra e sai do próprio vértice) e, não se considerando a possibilidade deles, na matriz D será marcado como 0, já que não é necessário nenhum movimento para se chegar aonde já está).\
Entre a linha 29 a 35 há o processamento feito pelo algoritmo em si: 